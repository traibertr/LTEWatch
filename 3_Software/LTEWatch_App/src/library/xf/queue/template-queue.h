/****************************************************************************************************************//**
 * Copyright (C) Hes-so VALAIS/WALLIS, HEI Sion, Infotronics. 2022
 * Created by Thomas Sterren (thomas.sterren@hevs.ch) & Patrice Rudaz (patrice.rudaz@hevs.ch)
 * All rights reserved.
 *
 * \file    template-queue.h
 *
 * \addtogroup XF eXecution Framework
 * \{
 *
 *
 * Initial author:  Patrice Rudaz
 * Creation date:   2015-01-09
 *
 * \author  Patrice Rudaz
 * \date    July 2018
 ********************************************************************************************************************/
#pragma once

/* **************************************************************************************************************** */
/*                                                                                                                  */
/* Header files                                                                                                     */
/*                                                                                                                  */
/* **************************************************************************************************************** */
#if defined( __cplusplus )
extern "C"
{
#endif
    #include <stdlib.h>
#if defined( __cplusplus )
}
#endif
//#include <config/assert-config.h>


/* **************************************************************************************************************** */
/*                                                                                                                  */
/* NAMESPACE Declaration                                                                                            */
/*                                                                                                                  */
/* **************************************************************************************************************** */
namespace std 
{

    /* ************************************************************************************************************ */
    /*                                                                                                              */
    /* Class Declaration                                                                                            */
    /*                                                                                                              */
    /* ************************************************************************************************************ */
    template <class _Tp, uint8_t MAX_SIZE>
    class queue
    {
    public:
        /* ******************************************************************************************************** */
        /*                                                                                                          */
        /* CONSTRUCTOR SECTION                                                                                      */
        /*                                                                                                          */
        /* ******************************************************************************************************** */
        queue() : _size(0), _pushIndex(0), _popIndex(0) {}

        /* ******************************************************************************************************** */
        /*                                                                                                          */
        /* PUBLIC DECLARATION SECTION                                                                               */
        /*                                                                                                          */
        /* ******************************************************************************************************** */
        /********************************************************************************************************//**
         * \brief   Returns true if no elements are queued.
         ************************************************************************************************************/
        bool empty() const                                      { return (_size == 0); }
        
        /********************************************************************************************************//**
         * \brief   Returns actual queued elements.
         ************************************************************************************************************/
        size_t size() const                                     { return _size; }
        
        /********************************************************************************************************//**
         * \brief   Returns maximum possible elements to be queued.
         ************************************************************************************************************/
        inline size_t maxSize() const                           { return MAX_SIZE; }

        /********************************************************************************************************//**
         * \brief   Access next element (oldest).
         ************************************************************************************************************/
        _Tp front();
        
        /********************************************************************************************************//**
         * \brief   Access next element (oldest).
         ************************************************************************************************************/
        const _Tp front() const;

        /********************************************************************************************************//**
         * \brief   Access last element (newest).
         ************************************************************************************************************/
        _Tp back();
        
        /********************************************************************************************************//**
         * \brief   Access last element (newest).
         ************************************************************************************************************/
        const _Tp back() const;

//        /********************************************************************************************************//**
//         * \brief   Access element at index.
//         ************************************************************************************************************/
//        _Tp getAt(int i);
//        
//        /********************************************************************************************************//**
//         * \brief   Access element atIndex
//         ************************************************************************************************************/
//        const _Tp getAt(int i) const;

        /********************************************************************************************************//**
         * \brief   Add element on the end of the queue.
         ************************************************************************************************************/
        void push(const _Tp x);
        
        /********************************************************************************************************//**
         * \brief   Remove element from top of the queue (oldest).
         ************************************************************************************************************/
        void pop();

    protected:
        /* ******************************************************************************************************** */
        /*                                                                                                          */
        /* PROTECTED DECLARATION SECTION                                                                            */
        /*                                                                                                          */
        /* ******************************************************************************************************** */
        void construct(_Tp __p, const _Tp& __val)               { /*::new(__p) _Tp(__val);*/ }
        void destroy(_Tp __p) { /*__p->~_Tp();*/ }

        inline uint8_t prevIndex(const uint8_t & index) const   { return ((index + maxSize() - 1) % maxSize()); }
        inline uint8_t nextIndex(const uint8_t & index) const   { return ((index + 1) % maxSize());}

    private:
        /* ******************************************************************************************************** */
        /*                                                                                                          */
        /* PRIVATE DECLARATION SECTION                                                                              */
        /*                                                                                                          */
        /* ******************************************************************************************************** */
        // Attributes
        _Tp _ringBuffer[MAX_SIZE];
        uint8_t _size;
        uint8_t _pushIndex;
        uint8_t _popIndex;
    };

    /* ************************************************************************************************************ */
    /*                                                                                                              */
    /* Template Declaration                                                                                         */
    /*                                                                                                              */
    /* ************************************************************************************************************ */
    template <class _Tp, uint8_t MAX_SIZE>
    _Tp queue<_Tp, MAX_SIZE>::front()
    {
        return _ringBuffer[_popIndex];
    }

    template <class _Tp, uint8_t MAX_SIZE>
    const _Tp queue<_Tp, MAX_SIZE>::front() const
    {
        return _ringBuffer[_popIndex];
    }

    template <class _Tp, uint8_t MAX_SIZE>
    _Tp queue<_Tp, MAX_SIZE>::back()
    {
        return _ringBuffer[prevIndex(_pushIndex)];
    }

    template <class _Tp, uint8_t MAX_SIZE>
    const _Tp queue<_Tp, MAX_SIZE>::back() const
    {
        return _ringBuffer[prevIndex(_pushIndex)];
    }

    template <class _Tp, uint8_t MAX_SIZE>
    void queue<_Tp, MAX_SIZE>::push(const _Tp x)
    {
        // Checks
        if (!empty())
        {
            //__ASSERT(_pushIndex != _popIndex);
        }

        if (_size < MAX_SIZE)
        {
            _size++;
            _ringBuffer[_pushIndex] = x;
            _pushIndex = nextIndex(_pushIndex);
        }
    }

    template <class _Tp, uint8_t MAX_SIZE>
    void queue<_Tp, MAX_SIZE>::pop()
    {
        if (!empty())
        {
            _size--;

            // Call destructor
            _ringBuffer[_popIndex] = NULL;
            _popIndex = nextIndex(_popIndex);
        }
    }

} // namespace std

/** \} */
